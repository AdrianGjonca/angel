#!/usr/bin/env python3

import sys
import os
import shutil
import subprocess

if len(sys.argv) < 2:
    print("Angel BuilDer cannot work if you don't give me a project root directory")
    sys.exit()

project_path = sys.argv[1]

if ("-h" in sys.argv) or ("--help" in sys.argv):
	print("This is the Angel BuilDer command")
	print("Use this to build your Angel-DT projects")
	print("")
	print("Syntax:")    
	print("         angel-bd [project-path]")
	print("")
	print("Required Project Layout:")
	print("         / (your project-path)")
	print("         |")
	print("         |")
	print("         |__src/")
	print("         |     |")
	print("         |     source files (*.c) [can include those in nested subdirs]")
	print("         | ")
	print("         |__headers/ ")
	print("         :     |")
	print("         :     header files (*.h) [can include those in nested subdirs]")
	print("         : ")
	print("         :..generated/ ")
	print("         :     :")
	print("         :     :..src/")
	print("         :     :     :")
	print("         :     :     Post-precompilation source files (*.c) [nested]")
	print("         :     : ")
	print("         :     :..headers/")
	print("         :           :")
	print("         :           Post-precompilation header files (*.h) [nested]")
	print("         : ")   
	print("         :..executable -> the executable file generated by compilation")
	print("")
	print("         (dotted lines show the files and directories generated at build)")
	print("         (regular lines show the files and directories you write yourself)")
	print("")
	sys.exit()


################################################
##
## 
## Functions
## 
##
################################################
def get_directories(path):
	#Chat GPT wrote this one line monstrosity
    return [os.path.join(path, entry) \
            for entry in os.listdir(path) \
            if os.path.isdir(os.path.join(path, entry))]

def get_directories_nameonly(path):
	#Chat GPT wrote this one line monstrosity
    return [entry for entry in os.listdir(path) \
            if os.path.isdir(os.path.join(path, entry))]

def get_all_file_paths(directory):
	#Credit to big man Chat-GPT (I know f*ckall python :( )
    file_paths = []
    for root, _, files in os.walk(directory):
        for file in files:
            file_paths.append(os.path.join(root, file))
    return file_paths
################################################
##
## 
## Main program
## 
##
################################################


#
#Check if project_path is a valid directory
#
if os.path.isdir(project_path):
	print(f"Project-Directory found {project_path}")
	#Rest carried on after the if statement
else:
	print("Directory not found")
	print("Check path given")
	sys.exit()


#
#Checks if project directories are set up correctly
#
pr_folders_nameonly = get_directories_nameonly(project_path) 
contains_src = \
	"src" in pr_folders_nameonly
 
contains_headers = \
	"headers" in pr_folders_nameonly

contains_all = contains_src and contains_headers

if not contains_all:
	print("Build Failed")
	if not contains_src:
		print("Missing src/ folder (angel-bd --help for info)")
	if not contains_headers:
		print("Missing headers/ folder (angel-bd --help for info)")
	sys.exit()
else:
	print("src/ and headers/ folders found")


#
#Get a list of all src and header files
#
src_files = []
header_files = []

src_folderPath = os.path.join(project_path, "src")
headers_folderPath = os.path.join(project_path, "headers")

src_files = get_all_file_paths(src_folderPath)
header_files = get_all_file_paths(headers_folderPath)
og_files = src_files + header_files

rel_src_files = [os.path.relpath(src_file, src_folderPath) \
                 for src_file in src_files]
rel_header_files = [os.path.relpath(header_file, headers_folderPath) \
                    for header_file in header_files]
rel_files = rel_src_files + rel_header_files


#
#Create list of src and header generated files
#
generated_folder = os.path.join(project_path, "generated")
generated_src_folder = os.path.join(generated_folder, "src")
generated_headers_folder = os.path.join(generated_folder, "headers")

generated_src_files = [os.path.join(generated_src_folder, src_file) \
					   for src_file in rel_src_files]
generated_header_files = [os.path.join(generated_headers_folder, header_file) \
					   for header_file in rel_header_files]
generated_files = generated_src_files + generated_header_files


#
#Create lists of folders to be made
#
tomake_folders_src = [os.path.dirname(src_file) \
					  for src_file in generated_src_files] + \
					 [os.path.dirname(header_file) \
					  for header_file in generated_header_files]


#
#Cleans the generated/ folder
#
if os.path.exists(generated_folder):
	shutil.rmtree(generated_folder)
	print("generated/ directory structure cleaned")
else:
	print("generated/ directory allready clean")


#
#Creates said folders/directories
#
for a_folder in tomake_folders_src:
	os.makedirs(a_folder, exist_ok=True)
print("generated/ directory structure made")


#
#Checks if angel-pc is installed
#
if not shutil.which("angel-pc"):
    print("Build Failed")
    print("The Angel PreCompiler is not installed on your system")
    print("(or is not setup in you PATH environment variable)")
    print("Please reinstall Angel Development Tools and try again!")
    sys.exit()


#
#Create a dictionary of source to output files
#
og_to_gen = dict()

for i in range(0, len(generated_files)):
	og_to_gen[og_files[i]] = generated_files[i]


#
#Precompiles the files
#
commands_to_execute = [ "angel-pc " + og_file + " -o " + og_to_gen[og_file] \
					    for og_file in og_files]
i = 0
for command in commands_to_execute:
	result = subprocess.run(command, shell=True, capture_output=True, text=True)
	print("----Precompiled " + og_files[i] + " to " + og_to_gen[og_files[i]])
	i += 1


#
#Create name for the executable
#
executable_file = os.path.join(project_path, "executable")

if os.name == "nt":
	executable_file += ".exe"


#
#Checks if gcc is installed
#
if not shutil.which("gcc"):
    print("Build Failed")
    print("GCC is not installed or installed incorrectly")
    print("Please (re)install GCC!")
    sys.exit()


#
#Create the gcc command we shall execute
#
compile_command = "gcc -I"
compile_command += generated_headers_folder
compile_command += " -o "
compile_command += executable_file
compile_command += " "
for the_src_file in generated_src_files:
	compile_command += the_src_file + " "

#
#Remove old executable
#
if os.path.exists(executable_file):
	print("Deleting old executable file")
	os.remove(executable_file)

#
#Compile
#

print("Calling GCC to compile")
result = subprocess.run(compile_command, shell=True, capture_output=True, text=True)
print("GCC Output :", result.stdout)
print("GCC Error  :", result.stderr)

#
#Summary
#

print("")
if os.path.exists(executable_file):
	print("Compilation appears to have been a SUCCESS!")
else:
	print("Compilation appears to have FAILED!")
print("")
















